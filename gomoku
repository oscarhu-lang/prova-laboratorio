import arcade
import os

BOARD_SIZE = 15
ASSETS_DIR = "assets"

BLACK_PIECE_IMAGE = os.path.join(ASSETS_DIR, "black_stone.png")
WHITE_PIECE_IMAGE = os.path.join(ASSETS_DIR, "white_stone.png")


class GomokuGame(arcade.Window):
    def __init__(self):
        super().__init__(600, 600, "Wuziqi")
        
        self.margin = 50
        self.cell_size = (self.width - 2 * self.margin) / (BOARD_SIZE - 1)
        
        self.pieces = arcade.SpriteList()
        self.board_state = {}  # (riga, colonna) -> "nero" o "bianco"
        self.current_player = "nero"
        self.game_over = False
        
        self.piece_scale = self.cell_size / 256 * 0.9
        arcade.set_background_color(arcade.color.BISQUE)
        
        # Etichetta del giocatore corrente
        self.player_label = None
        self.winner_label = None
        
    def setup(self):
        """Inizializza il gioco"""
        self.update_player_label()
        
    def on_draw(self):
        self.clear()
        
        # Disegna la griglia della scacchiera
        for i in range(BOARD_SIZE):
            # Linee orizzontali
            y = self.margin + i * self.cell_size
            arcade.draw_line(
                self.margin, y, 
                self.width - self.margin, y, 
                arcade.color.BLACK, 2
            )
            
            # Linee verticali
            x = self.margin + i * self.cell_size
            arcade.draw_line(
                x, self.margin, 
                x, self.height - self.margin, 
                arcade.color.BLACK, 2
            )
        
        # Disegna i punti stella (tradizione Go)
        punti_stella = [3, 7, 11]  # Punti stella per scacchiera 15x15
        for riga in punti_stella:
            for colonna in punti_stella:
                x, y = self.coordinate_to_pixel(riga, colonna)
                arcade.draw_circle_filled(x, y, 5, arcade.color.BLACK)
        
        # Disegna tutte le pietre
        self.pieces.draw()
        
        # Disegna il bordo
        arcade.draw_rectangle_outline(
            self.width // 2, self.height // 2,
            self.width - 2 * self.margin, self.height - 2 * self.margin,
            arcade.color.BLACK, 3
        )
        
        # Mostra le etichette
        if self.player_label:
            self.player_label.draw()
        if self.winner_label:
            self.winner_label.draw()
    
    def on_mouse_press(self, x, y, bottone, modificatori):
        """Gestisce il click del mouse"""
        if self.game_over:
            return
            
        # Ottieni l'intersezione più vicina della griglia
        riga, colonna = self.get_intersezione_vicina(x, y)
        
        # Se clicchi fuori dalla scacchiera, o la posizione è già occupata, ritorna
        if riga is None or (riga, colonna) in self.board_state:
            return
        
        # Ottieni le coordinate pixel dell'intersezione
        px, py = self.coordinate_to_pixel(riga, colonna)
        
        # Crea la pietra corrispondente al giocatore corrente
        if self.current_player == "nero":
            pietra = arcade.Sprite(BLACK_PIECE_IMAGE, self.piece_scale)
            self.board_state[(riga, colonna)] = "nero"
            self.current_player = "bianco"
        else:
            pietra = arcade.Sprite(WHITE_PIECE_IMAGE, self.piece_scale)
            self.board_state[(riga, colonna)] = "bianco"
            self.current_player = "nero"
        
        # Imposta la posizione della pietra e aggiungila alla lista
        pietra.center_x = px
        pietra.center_y = py
        self.pieces.append(pietra)
        
        # Aggiorna l'etichetta del giocatore
        self.update_player_label()
        
        # Controlla se c'è un vincitore
        if self.controlla_vittoria(riga, colonna):
            self.game_over = True
            vincitore = "Nero" if self.board_state[(riga, colonna)] == "nero" else "Bianco"
            self.winner_label = arcade.Text(
                f"{vincitore} Vince!",
                self.width // 2, self.height - 30,
                arcade.color.RED, 28,
                anchor_x="center",
                bold=True
            )
            
            # Aggiorna l'etichetta del giocatore per mostrare il risultato
            self.player_label = arcade.Text(
                "Clicca per ricominciare",
                self.width // 2, 50,
                arcade.color.DARK_BLUE, 16,
                anchor_x="center"
            )
    
    def update_player_label(self):
        """Aggiorna l'etichetta del giocatore corrente"""
        giocatore = "Bianco" if self.current_player == "bianco" else "Nero"
        self.player_label = arcade.Text(
            f"Giocatore Corrente: {giocatore}",
            self.width // 2, 20,
            arcade.color.BLACK, 18,
            anchor_x="center"
        )
    
    def coordinate_to_pixel(self, riga, colonna):
        """Converte coordinate griglia in coordinate pixel"""
        return (
            self.margin + colonna * self.cell_size,
            self.margin + riga * self.cell_size
        )
    
    def get_intersezione_vicina(self, x, y):
        """Ottiene l'intersezione della griglia più vicina al click"""
        # Calcola la coordinata della griglia più vicina
        colonna = round((x - self.margin) / self.cell_size)
        riga = round((y - self.margin) / self.cell_size)
        
        # Assicurati che le coordinate siano dentro la scacchiera
        if 0 <= riga < BOARD_SIZE and 0 <= colonna < BOARD_SIZE:
            return riga, colonna
        return None, None
    
    def controlla_vittoria(self, riga, colonna):
        """Controlla se ci sono 5 pietre consecutive"""
        if (riga, colonna) not in self.board_state:
            return False
            
        giocatore = self.board_state[(riga, colonna)]
        direzioni = [
            [(0, 1), (0, -1)],   # Direzione verticale
            [(1, 0), (-1, 0)],   # Direzione orizzontale
            [(1, 1), (-1, -1)],  # Diagonale (alto-sinistra a basso-destra)
            [(1, -1), (-1, 1)]   # Diagonale (alto-destra a basso-sinistra)
        ]
        
        for coppia_direzioni in direzioni:
            conteggio = 1  # La posizione corrente ha già 1 pietra
            
            # Controlla in entrambe le direzioni opposte
            for dx, dy in coppia_direzioni:
                riga_corrente, colonna_corrente = riga, colonna
                
                # Controlla le pietre consecutive in questa direzione
                while True:
                    riga_corrente += dx
                    colonna_corrente += dy
                    
                    # Controlla se è ancora dentro la scacchiera e se è la stessa pietra
                    if (0 <= riga_corrente < BOARD_SIZE and 
                        0 <= colonna_corrente < BOARD_SIZE and 
                        (riga_corrente, colonna_corrente) in self.board_state and
                        self.board_state[(riga_corrente, colonna_corrente)] == giocatore):
                        conteggio += 1
                    else:
                        break
            
            # Se ci sono 5 o più pietre consecutive, vittoria
            if conteggio >= 5:
                return True
        
        return False
    
    def on_mouse_release(self, x, y, bottone, modificatori):
        """Riavvia il gioco se è finito"""
        if self.game_over:
            self.reset_game()
    
    def reset_game(self):
        """Riavvia il gioco"""
        self.pieces = arcade.SpriteList()
        self.board_state = {}
        self.current_player = "nero"
        self.game_over = False
        self.winner_label = None
        self.update_player_label()


if __name__ == "__main__":
    gioco = GomokuGame()
    gioco.setup()
    arcade.run()
